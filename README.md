* このパッケージはプライベートパッケージとなる

# フェッチャー
* フェッチャーについては[こちら](https://github.com/megur0/firestore_fetcher)を参照

# Firestoreをリソースとした無限スクロールの実現
* 参考
    * https://qiita.com/kontikun/items/f4326928cbe1c8134408
    * https://qiita.com/kontikun/items/94e30c59d4694beb4b4a
* 大きく分けて2種類を検討・実装した
    |方式|内容|メリット|デメリット|
    |-|-|-|-|
    |シンプル方式|・全てのデータ(新規・更新・削除を含む)をストリームから受信する<br/>・追加取得はlimitの件数を増加させてサブスクリプションを再生成|ストリームで受信したデータをそのまま利用できるためシンプル|追加取得の取得件数が冗長となる|
    |ハイブリッド方式|・初期取得、追加取得は非ストリームデータとして取得して既存リストの末尾へマージする<br/>・新規・更新は更新日時の降順でストリームから受信して既存リストへマージ<br/>※マージは変更タイプ・データ内容に応じたマージ処理を行う。|シンプル方式と違って追加取得の件数が冗長ではない *1|・実装が複雑<br/>・"更新日時"のフィールドが必要<br/>・物理削除は対応できない|
    * *1 追加取得においてはハイブリッド方式が効率的だが、更新が非常に多いケースではシンプルタイプの方が効率的になる場合もある。
        * 極端な例として、100万件の頻繁に変更されるデータから 20件ずつデータを無限スクロールで表示するケース

# シンプル方式
![](./doc/svg/firestore_fetcher_simple.drawio.svg)

# ハイブリッド方式
![](./doc/svg/firestore_fetcher_hybrid.drawio.svg)
* 更新日時のフィールドがドキュメントに存在することが必須となる。
    * 新規作成時にセットされる
    * 更新時(削除時含む)に更新される
* 削除については「論理削除」として更新データとして対応する。
    * 削除日時のフィールドを用意する
    * ドキュメントの削除時に削除日時、更新日時を更新する。
* Firestore SDKの DocumentChangeTypeを利用する。
    * これは **取得結果に対して** の変更の種類であって"データベース上での変更"ではない。
        ||表すもの|
        |-|-|
        |added|取得結果に新たに含まれるようになった<br/>※ストリームの初回のデータは全てaddedになる|
        |modified|取得結果に含まれていたがその内容が変わった|
        |removed|取得結果に含まれなくなった|
    * 例えばあるドキュメントが "added" とされているならば、それは新たに取得結果に含まれるようになったことが分かる。
        * しかし、そのドキュメントがデータベース上で新規に追加されたのか更新されたかという情報は含まれない。
## 新規・更新されたデータのマージ
* デフォルトの動作は「addedは全て追加」「modifiedは入れ替え」「removedは無視」として、最後にソートをする。
* しかし、要件によってはデフォルトの動作では満たすことができないため、マージの処理はコールバックを渡すことでインジェクション可能としている。
* 具体例を以下に示す。（ソートについて記載を省略)
    |例|表示順|added|modified|removed|
    |-|-|-|-|-|
    |チャットメッセージ(変更不可)<br/>※デフォルトの動作で対応可能|作成日時の降順|全て追加|入れ替え|無視|
    |チャットメッセージ(変更可)|作成日時の降順|(modifiedと合わせて処理)|・既存のリストが空なら全て追加(新着)<br/>・既存のリストに存在するドキュメントIDなら入れ替える<br/>・既存のリストに存在しないなら先頭データの作成日時より新しい場合(新着)のみ追加<br/>・削除日時が設定されている場合は既存リストから削除|無視|
    |チャットルーム一覧<br/>※デフォルトの動作で対応可能|更新日時の降順|全て追加|入れ替え|無視|
    


